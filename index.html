<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fusion Power Plant Economics Calculator</title>
<style>
  :root{
    --bg:#eaf2f7;
    --atom:#8a8f98;
    --card:#fff; --ink:#1f2937; --muted:#6b7280;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color:var(--ink);
    background: var(--bg);
    position:relative;
  }
  body::before{
    content:"";
    position:fixed; inset:0;
    background:
      url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="140" height="140" viewBox="0 0 140 140"><g fill="none" stroke="%238a8f98" stroke-width="1" opacity="0.4"><circle cx="70" cy="70" r="3" fill="%238a8f98"/><ellipse cx="70" cy="70" rx="24" ry="11"/><ellipse cx="70" cy="70" rx="33" ry="16" transform="rotate(60 70 70)"/><ellipse cx="70" cy="70" rx="28" ry="14" transform="rotate(120 70 70)"/><circle cx="48" cy="70" r="2.5" fill="%238a8f98"/><circle cx="92" cy="70" r="2.5" fill="%238a8f98"/><circle cx="70" cy="44" r="2.5" fill="%238a8f98"/><circle cx="70" cy="96" r="2.5" fill="%238a8f98"/></g></svg>')
      repeat;
    background-size:140px 140px;
    z-index:-1;
  }

  .site-header{padding:20px 16px 10px; border-bottom:1px solid #e5e7eb; background:#fff; display:flex; flex-direction:column; align-items:center;}
  .brand{max-width:1100px; margin:0 auto; text-align:center}
  .brand img{height:56px; width:auto; display:block; margin:0 auto 8px}
  .brand h1{margin:2px 0 4px; font-size:26px; font-weight:800; letter-spacing:.2px}
  .brand p.subtitle{margin:0; color:#4b5563; font-size:14px; line-height:1.4}
  .header-actions{ width:100%; display:flex; justify-content:center; margin-top:8px; }
  .btn-guide{ font-size:12px; padding:8px 12px; border:1px solid #e5e7eb; border-radius:9999px; background:#f8fafc; font-weight:700; cursor:pointer; }
  .btn-guide:hover{ border-color:#cbd5e1; }

  main{max-width:1100px; margin:0 auto; padding:16px; display:grid; gap:16px; grid-template-columns: 1fr;}
  section.card{background:var(--card); border:1px solid #e5e7eb; border-radius:12px; padding:16px}
  h2{margin:0 0 12px; font-size:16px}
  .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
  button{padding:8px 12px; border:1px solid #e5e7eb; background:#f8fafc; border-radius:8px; font-weight:600; cursor:pointer}
  button:hover{border-color:#cbd5e1}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; font-weight:700}
  .ok{color:#065f46; background:#d1fae5}
  .bad{color:#7f1d1d; background:#fecaca}
  .row2{display:grid; grid-template-columns:1fr 1fr; gap:12px}
  @media (max-width: 900px){ .row2{grid-template-columns:1fr} }
  .controls{display:grid; grid-template-columns:repeat(6,1fr); gap:8px}
  @media (max-width: 900px){ .controls{grid-template-columns:repeat(3,1fr)} }
  .toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin:8px 0 0}
  textarea{width:100%; height:120px; padding:8px; border:1px solid #e5e7eb; border-radius:8px; font-size:13px}
  .small{font-size:12px; color:#6b7280}
  canvas{width:100%; height:520px; border:1px solid #e5e7eb; border-radius:8px; background:#fff}

  .params-grid{
    display:grid;
    grid-template-columns: 300px 1fr 120px 100px 70px 120px;
    gap:10px 12px;
    align-items:center;
  }
  @media (max-width: 900px){
    .params-grid{ grid-template-columns: 220px 1fr 110px 90px 60px 110px; }
  }
  .params-grid .colhead{
    font-weight:700; font-size:13px; color:#374151; padding-bottom:4px; border-bottom:1px solid #e5e7eb;
  }
  .params-grid .colhead.center{ text-align:center; }
  .paramlabel{ font-weight:600; font-size:14px; line-height:1.2; }
  .paramslider{ width:100%; }
  .paramnum, .paramscale{ width:100%; }
  .paramlock, .paramw{ display:flex; justify-content:center; align-items:center; }
  .paramw input{ width:100%; }
  .params-grid input[type="range"]{ margin:0; }

  .preset-bar{display:flex; flex-wrap:wrap; gap:8px; margin:10px 0 14px}
  .preset-bar button{font-size:12px; padding:6px 10px}

  footer{max-width:1100px; margin:8px auto 24px; padding:0 16px; color:var(--muted); font-size:12px; text-align:center}

  .guide-backdrop{
    position: fixed; inset: 0;
    background: rgba(17, 24, 39, 0.45);
    backdrop-filter: blur(2px);
    z-index: 1000;
  }
  .guide-modal{
    position: fixed; inset: 6% 6% auto 6%;
    max-height: 88vh;
    background: #ffffff;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    box-shadow: 0 20px 50px rgba(0,0,0,.2);
    padding: 0;
    z-index: 1001;
    display: flex; flex-direction: column;
  }
  .guide-header{
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 14px; border-bottom: 1px solid #e5e7eb;
  }
  .guide-header h2{ margin: 0; font-size: 18px; }
  .guide-close{
    border: 1px solid #e5e7eb; background: #f8fafc;
    border-radius: 8px; padding: 6px 10px; cursor: pointer;
  }
  .guide-body{
    padding: 14px; overflow: auto;
    display: grid; grid-template-columns: 260px 1fr; gap: 16px;
  }
  .guide-toc{ font-size: 14px; }
  .guide-toc ol{ margin: 8px 0 0 18px; padding: 0; }
  .guide-body h3{ margin: 12px 0 6px; font-size: 16px; }
  .guide-body p, .guide-body li{ font-size: 14px; line-height: 1.45; color: #374151; }
  .hidden{ display: none !important; }
  @media (max-width: 900px){
    .guide-body{ grid-template-columns: 1fr; }
  }

  .linklike{ background:none; border:none; padding:0; font:inherit; color:#2563eb; cursor:pointer; text-decoration:underline; }
  .linklike:hover{ text-decoration:none; }

  .legend{ display:flex; gap:10px; flex-wrap:wrap; margin-top:6px; font-size:12px; color:#374151; align-items:center; }
  .legend-row{ display:inline-flex; align-items:center; gap:6px; }
  .legend-row .swatch{
    display:inline-block; width:14px; height:14px;
    border:2px solid #111827; background:#ffffff; border-radius:2px;
    position:relative; vertical-align:middle;
  }
  .legend-row .swatch.circle{ border-radius:50%; }
  .legend-row .swatch.square{ border-radius:2px; }
  .legend-row .swatch.infeasible{ border-color:#ef4444; background:transparent; }
  .legend-row .swatch.infeasible::before,
  .legend-row .swatch.infeasible::after{
    content:""; position:absolute; left:2px; right:2px; top:4px; height:2px; background:#ef4444;
  }
  .legend-row .swatch.infeasible::before{ transform:rotate(45deg); }
  .legend-row .swatch.infeasible::after{ transform:rotate(-45deg); }
</style>

<style>
#guideModal {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
#guideModal section {
  margin-bottom: 1.2em;
  padding: 0.5em 0;
}
#guideModal h2, #guideModal h3 {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}
#guideModal p, #guideModal ul, #guideModal ol { }
</style>

<style>
/* User's Guide modal */
.guide-backdrop{
  position: fixed; inset: 0;
  background: rgba(17, 24, 39, 0.45); /* #111827 with alpha */
  backdrop-filter: blur(2px);
  z-index: 1000;
}
.guide-modal{
  position: fixed; inset: 6% 6% auto 6%;
  max-height: 88vh;
  background: #ffffff;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  box-shadow: 0 20px 50px rgba(0,0,0,.2);
  padding: 0;
  z-index: 1001;
  display: flex; flex-direction: column;
}
.guide-header{
  display: flex; align-items: center; justify-content: space-between;
  padding: 12px 14px; border-bottom: 1px solid #e5e7eb;
}
.guide-header h2{ margin: 0; font-size: 18px; }
.guide-close{
  border: 1px solid #e5e7eb; background: #f8fafc;
  border-radius: 8px; padding: 6px 10px; cursor: pointer;
}
.guide-body{
  padding: 14px; overflow: auto;
  display: grid; grid-template-columns: 260px 1fr; gap: 16px;
}
.guide-toc{ font-size: 14px; }
.guide-toc ol{ margin: 8px 0 0 18px; padding: 0; }
.guide-body h3{ margin: 12px 0 6px; font-size: 16px; }
.guide-body p, .guide-body li{ font-size: 14px; line-height: 1.45; color: #374151; }
.hidden{ display: none !important; }
@media (max-width: 900px){
  .guide-body{ grid-template-columns: 1fr; }
</style>

<style>
/* ------- Guide alignment overrides ------- */
/* Normalize list spacing inside guide content */
.guide-body ul, .guide-body ol { margin: 0 0 8px 0; padding-left: 1.2em; }

#guideModal p, #guideModal ul, #guideModal ol { }
.guide-body { display: grid; grid-template-columns: 260px 1fr; gap: 16px; }
.guide-toc { grid-column: 1; }
.guide-body > section { grid-column: 2; margin: 0 0 14px 0; }
.guide-body h3 { margin: 12px 0 6px; }
.guide-body p, .guide-body li { margin: 0 0 8px 0; }
</style>


<style>
.plot-wrap{ position: relative; display: inline-block; }
.plot-reset{
  position: absolute; top: 8px; right: 8px; z-index: 10;
  font-size: 12px; padding: 6px 10px;
  border: 1px solid #cbd5e1; background: #f8fafc; border-radius: 8px; cursor: pointer;
}
.plot-reset:hover{ background:#eef2f7; }
</style>

<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

<style id="plotly-overlay-css">
  .plot-wrap { position: relative; }
  #plotlyOverlay { position: absolute; inset: 0; }
  /* Keep reset button pinned to upper-right of the plot */
  .plot-reset { position: absolute; top: 8px; right: 8px; z-index: 10; }
</style>


<style id="controls-split-override">
  .controls{display:grid; grid-template-columns:repeat(4,1fr); gap:8px}
  .controls .break{grid-column:1 / -1;}
</style>


<style id="tooltip-css">
  [data-tooltip]{ position: relative; }
  [data-tooltip]::after{
    content: attr(data-tooltip);
    position: absolute;
    left: 50%;
    top: 0;
    transform: translate(-50%, calc(-100% - 8px));
    background: rgba(17,17,17,.92);
    color: #fff;
    padding: 6px 8px;
    border-radius: 6px;
    font-size: 12px;
    line-height: 1.2;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity .12s ease 0s;
    z-index: 9999;
  }
  [data-tooltip]::before{
    content: '';
    position: absolute;
    left: 50%;
    top: -8px;
    transform: translateX(-50%);
    border: 8px solid transparent;
    border-top: none;
    border-bottom-color: rgba(17,17,17,.92);
    opacity: 0;
    transition: opacity .12s ease 0s;
    z-index: 9999;
  }
  [data-tooltip]:hover::after,
  [data-tooltip]:hover::before{ opacity: 1;  transition-delay: .35s; }
</style>
</head>
<body>
  <header class="site-header">
    <div class="brand">
      <img src="REVLogo.JPG" alt="REV Logo" />
      <h1>Fusion Power Plant Economics Calculator</h1>
      <p class="subtitle">Advanced techno-economic analysis tool based on Whyte et al., 2025, "Techno-Economic Analysis of Fusion Energy, Part 1: An Economic Lawson Criterion"</p>
    </div>
    <div class="header-actions">
      <button id="btnGuide" type="button" class="btn-guide">User's Guide</button>
    </div>
  </header>

  <main>
    <section class="card">
      <h2>Parameters</h2>

      <div class="preset-bar">
        <button type="button" data-preset="nominal">Nominal</button>
        <button type="button" data-preset="aries-at">ARIES-AT</button>
        <button type="button" data-preset="arc">ARC</button>
        <button type="button" data-preset="sparc">SPARC-like</button>
        <button type="button" data-preset="optimistic">Optimistic</button>
        <button type="button" data-preset="conservative">Conservative (non-viable)</button>
      </div>

      <div class="params-grid" id="paramGrid">
        <div class="colhead">Parameter (units)</div>
        <div class="colhead">Slider</div>
        <div class="colhead">Value</div>
        <div class="colhead">Scale</div>
        <div class="colhead center">Lock</div>
        <div class="colhead center">Weight (w)</div>

        <label for="PfS_num" class="paramlabel">Areal fusion power density <span class="mono">Pf/S</span> [MW/m²]</label>
        <input id="PfS_rng" class="paramslider" type="range" min="0.5" max="10" step="0.01" value="2.5" />
        <input id="PfS_num" class="paramnum" type="number" step="0.01" value="2.5" />
        <select id="PfS_scale" class="paramscale"><option value="lin" selected>LIN</option><option value="log">LOG</option></select>
        <div class="paramlock"><input id="PfS_lock" type="checkbox"></div>
        <div class="paramw"><input id="PfS_w" type="number" step="0.01" value="1"></div>

        <label for="tau_rep_num" class="paramlabel">Surface replacement time <span class="mono">τrep</span> [y]</label>
        <input id="tau_rep_rng" class="paramslider" type="range" min="0" max="0.5" step="0.001" value="0.10" />
        <input id="tau_rep_num" class="paramnum" type="number" step="0.001" value="0.10" />
        <select id="tau_rep_scale" class="paramscale"><option value="lin" selected>LIN</option><option value="log">LOG</option></select>
        <div class="paramlock"><input id="tau_rep_lock" type="checkbox"></div>
        <div class="paramw"><input id="tau_rep_w" type="number" step="0.01" value="1"></div>

        <label for="tau_life_num" class="paramlabel">Plant lifetime <span class="mono">τlife</span> [y]</label>
        <input id="tau_life_rng" class="paramslider" type="range" min="5" max="60" step="0.1" value="30" />
        <input id="tau_life_num" class="paramnum" type="number" step="0.1" value="30" />
        <select id="tau_life_scale" class="paramscale"><option value="lin" selected>LIN</option><option value="log">LOG</option></select>
        <div class="paramlock"><input id="tau_life_lock" type="checkbox"></div>
        <div class="paramw"><input id="tau_life_w" type="number" step="0.01" value="1"></div>

        <label for="POE_num" class="paramlabel">Price of energy <span class="mono">POE</span> [$/MWh]</label>
        <input id="POE_rng" class="paramslider" type="range" min="20" max="200" step="1" value="100" />
        <input id="POE_num" class="paramnum" type="number" step="1" value="100" />
        <select id="POE_scale" class="paramscale"><option value="lin" selected>LIN</option><option value="log">LOG</option></select>
        <div class="paramlock"><input id="POE_lock" type="checkbox"></div>
        <div class="paramw"><input id="POE_w" type="number" step="0.01" value="1"></div>

        <label for="XS_num" class="paramlabel">Fluence limit <span class="mono">XS</span> [MW·y/m²]</label>
        <input id="XS_rng" class="paramslider" type="range" min="0.5" max="6" step="0.01" value="3.125" />
        <input id="XS_num" class="paramnum" type="number" step="0.01" value="3.125" />
        <select id="XS_scale" class="paramscale"><option value="lin" selected>LIN</option><option value="log">LOG</option></select>
        <div class="paramlock"><input id="XS_lock" type="checkbox"></div>
        <div class="paramw"><input id="XS_w" type="number" step="0.01" value="1"></div>

        <label for="etaE_num" class="paramlabel">Net conversion efficiency <span class="mono">ηE</span> [—]</label>
        <input id="etaE_rng" class="paramslider" type="range" min="0.1" max="0.7" step="0.001" value="0.40" />
        <input id="etaE_num" class="paramnum" type="number" step="0.001" value="0.40" />
        <select id="etaE_scale" class="paramscale"><option value="lin" selected>LIN</option></select>
        <div class="paramlock"><input id="etaE_lock" type="checkbox"></div>
        <div class="paramw"><input id="etaE_w" type="number" step="0.01" value="1"></div>

        <label for="cY_num" class="paramlabel">Target cost per yield <span class="mono">(c/Y)target</span> [$/MJ]</label>
        <input id="cY_rng" class="paramslider" type="range" min="0" max="0.01" step="0.0001" value="0.0000" />
        <input id="cY_num" class="paramnum" type="number" step="0.0001" value="0.0000" />
        <select id="cY_scale" class="paramscale"><option value="lin" selected>LIN</option><option value="log">LOG</option></select>
        <div class="paramlock"><input id="cY_lock" type="checkbox"></div>
        <div class="paramw"><input id="cY_w" type="number" step="0.01" value="1"></div>

        <label for="MS_S_num" class="paramlabel">Surface areal cost <span class="mono">(M$/S)S</span> [M$/m²]</label>
        <input id="MS_S_rng" class="paramslider" type="range" min="0" max="1.0" step="0.01" value="0.10" />
        <input id="MS_S_num" class="paramnum" type="number" step="0.01" value="0.10" />
        <select id="MS_S_scale" class="paramscale"><option value="lin" selected>LIN</option><option value="log">LOG</option></select>
        <div class="paramlock"><input id="MS_S_lock" type="checkbox"></div>
        <div class="paramw"><input id="MS_S_w" type="number" step="0.01" value="1"></div>

        <label for="MS_ON_num" class="paramlabel">Overnight areal cost <span class="mono">(M$/S)O/N</span> [M$/m²]</label>
        <input id="MS_ON_rng" class="paramslider" type="range" min="3" max="20" step="0.1" value="10.0" />
        <input id="MS_ON_num" class="paramnum" type="number" step="0.1" value="10.0" />
        <select id="MS_ON_scale" class="paramscale"><option value="lin" selected>LIN</option><option value="log">LOG</option></select>
        <div class="paramlock"><input id="MS_ON_lock" type="checkbox"></div>
        <div class="paramw"><input id="MS_ON_w" type="number" step="0.01" value="1"></div>

        <label for="iRate_num" class="paramlabel">Cost of capital <span class="mono">i</span> [%]</label>
        <input id="iRate_rng" class="paramslider" type="range" min="0" max="15" step="0.1" value="5.0" />
        <input id="iRate_num" class="paramnum" type="number" step="0.1" value="5.0" />
        <select id="iRate_scale" class="paramscale"><option value="lin" selected>LIN</option><option value="log">LOG</option></select>
        <div class="paramlock"><input id="iRate_lock" type="checkbox"></div>
        <div class="paramw"><input id="iRate_w" type="number" step="0.01" value="1"></div>
      </div>

      <div class="toolbar" style="margin-top:10px">
        <label class="small"><input type="checkbox" id="liveProj" /> Real-time projection preview (debounced)</label>
        <label class="small">Targets (Q): <input id="targetsInput" type="text" value="1.0, 1.5" style="width:200px; margin-left:6px"></label>
        <label class="small"><input type="checkbox" id="utilEnforce" checked /> Require U ≥</label>
        <input id="utilMin" type="number" step="0.01" min="0" max="1" value="0.80" style="width:70px">
      </div>

      <div class="btns">
        <button id="btnQ" data-tooltip="Compute Qecon(x) for the current parameter set">Compute Qecon(x)</button>
        <button id="btnProj" data-tooltip="Full projection to all targets (compute projected points)">Full projection to all targets</button>
        <button id="btnReset">Reset to nominal</button>
        <button id="btnExport" data-tooltip="Export current parameter set and settings as JSON">Export JSON</button>
        <input type="file" id="fileImport" accept=".json" style="display:none"/>
        <button id="btnImport" data-tooltip="Import JSON from a file (opens file chooser)">Import JSON</button>
        <button id="btnApplyJSON" data-tooltip="Apply JSON from the textbox to the app">Apply JSON (from box)</button>
        <button id="btnExportCSV" data-tooltip="Export projection results as a CSV file">Export projections CSV</button>
      </div>

      <div style="margin-top:8px">
        <label for="jsonBox"><strong>JSON box</strong> (paste or inspect parameter sets)</label>
        <textarea id="jsonBox" class="mono"></textarea>
      </div>

      <div class="row2" style="margin-top:12px">
        <section class="card">
          <h2>Current point x</h2>
          <div id="statusX" class="mono"></div>
        </section>
        <section class="card">
          <h2>Projection results (nearest y per target)</h2>
          <div id="statusY" class="mono"></div>
        </section>
      </div>
    </section>

    <section class="card">
      <h2>2-D Heatmap of Qecon with contours</h2>
      <div class="controls">
        <div><label for="xParam">X-axis</label><select id="xParam"></select></div>
        <div><label for="yParam">Y-axis</label><select id="yParam"></select></div>
        <div><label for="resSelect">Resolution</label>
          <select id="resSelect"><option value="64">64×64</option><option value="96" selected>96×96</option><option value="128">128×128</option></select>
        </div>
        <div class="break"></div>
        <div><label for="xmin">X min</label><input id="xmin" type="number" step="any" value="0.5"></div>
        <div><label for="xmax">X max</label><input id="xmax" type="number" step="any" value="6"></div>
        <div><label for="ymin">Y min</label><input id="ymin" type="number" step="any" value="0.5"></div>
        <div><label for="ymax">Y max</label><input id="ymax" type="number" step="any" value="6"></div>
        <div class="break"></div>
        <div><label for="contoursInput">Contour Q levels</label><input id="contoursInput" type="text" value="1.0, 1.5, 2.0"></div>
      </div>
      <div class="legend" id="legend"></div>
      <div class="toolbar">
        <button id="btnDownloadPNG" title="Download the current plot as a PNG image" aria-label="Download the current plot as a PNG image" data-tooltip="Download the current plot as a PNG image">Download PNG</button>
        <span class="small">
          <button id="btnAxesPfS_XS" class="linklike" type="button" title="Quick axes: set X = Pf/S and Y = XS; updates bounds" aria-label="Quick axes: set X = Pf/S and Y = XS; updates bounds" data-tooltip="Quick axes: X = Pf/S, Y = XS; updates bounds">Pf/S vs XS</button>
          •
          <button id="btnAxesPfS_tau" class="linklike" type="button" title="Quick axes: set X = Pf/S and Y = tau_rep; updates bounds" aria-label="Quick axes: set X = Pf/S and Y = tau_rep; updates bounds" data-tooltip="Quick axes: X = τrep; updates bounds">Pf/S vs τrep</button> </span>
      </div>
      <div class="plot-wrap"><button id="btnResetView" class="plot-reset" type="button" title="Reset view to defaults" data-tooltip="Reset view: fit axes to include all points and contours">Reset view</button><canvas id="plot" width="820" height="520"></canvas><div id="plotlyOverlay" class="plotly-overlay"></div></div>
    </section>
  </main>

  <footer>
    © 2025 by Rutherford Energy Ventures, All Rights Reserved
  </footer>

  <!-- User's Guide Modal -->
<div id="guideBackdrop" class="guide-backdrop hidden" aria-hidden="true"></div>
<aside id="guideModal" class="guide-modal hidden" role="dialog" aria-modal="true" aria-labelledby="guideTitle">

  <header class="guide-header">
    <h2 id="guideTitle">User’s Guide</h2>
    <button id="guideClose" class="guide-close" aria-label="Close User’s Guide">✕</button>
  </header>

  <div class="guide-body">
    <!-- Table of Contents -->
    <nav class="guide-toc">
      <strong>Contents</strong>
      <ol>
        <li><a href="#g-overview">Overview & Quick Start</a></li>
        <li><a href="#g-parameters">Parameters Panel</a></li>
        <li><a href="#g-projection">Projection (Targets Q, Utilization)</a></li>
        <li><a href="#g-presets">Presets</a></li>
        <li><a href="#g-visualization">Visualization (Heatmap & Contours)</a></li>
        <li><a href="#g-save">Save / Restore & Export</a></li>
        <li><a href="#g-tips">Tips, Notes & FAQ</a></li>
      </ol>
    </nav>

    <!-- 1. Overview -->
    <section id="g-overview">
      <h3>1. Overview & Quick Start</h3>
      <p>
        This tool implements the economic Lawson framework to assess fusion power-plant viability. 
        It computes the economic gain \(Q_{\mathrm{econ}}\) from your input parameters and can 
        <em>project</em> infeasible designs to nearby viable ones at selected target Q levels.
      </p>
      <ol>
        <li>Choose or adjust **parameters** with sliders/inputs.</li>
        <li>Optionally enable **Real-time projection (debounced)** for fast previews.</li>
        <li>Set target **Q** values (e.g., <span class="mono">1.0, 1.5</span>), and, if needed, enforce **U ≥** (utilization).</li>
        <li>Click **Full projection to all targets** for accurate nearest viable designs.</li>
        <li>Explore the **heatmap** (2-D slices of Q) with multiple contours.</li>
        <li>**Export** JSON (state), **Import/Apply** JSON to restore, and **Export projections CSV** to share results.</li>
      </ol>
    </section>

    <!-- 2. Parameters -->
    <section id="g-parameters">
      <h3>2. Parameters Panel</h3>
      <ul>
        <li><strong>Sliders + Value boxes:</strong> change any of the ten inputs (Pf/S, τrep, τlife, POE, XS, ηE, (c/Y), (M$/S)S, (M$/S)O/N, <em>i (cost of capital)</em>).</li>
        <li><strong>Scale:</strong> toggle **LIN / LOG** slider scaling for positive-domain parameters.</li>
        <li><strong>Lock:</strong> if checked, the parameter is held fixed during projection.</li>
        <li><strong>Weight (w):</strong> distance weight in the projection metric (set to 0 to ignore a parameter in the distance).</li>
        <li><strong>Live Q & U:</strong> the “Current point x” card always shows \(Q_{\mathrm{econ}}(x)\) and utilization \(U(x)\).</li>
      </ul>
    </section>

    <!-- 3. Projection -->
    <section id="g-projection">
      <h3>3. Projection (Targets Q, Utilization)</h3>
      <p>
        The app finds the nearest point <em>y</em> (by a weighted, scaled Euclidean metric) such that 
        \(Q_{\mathrm{econ}}(y) \ge \text{target}\), with optional utilization constraint \(U(y) \ge U_{\min}\).
      </p>
      <ul>
        <li><strong>Targets (Q):</strong> enter comma-separated values (e.g., <span class="mono">1.0, 1.5, 2.0</span>). The app computes a projection for <em>each</em> target.</li>
        <li><strong>Require U ≥</strong> enables a utilization floor (e.g., 0.80). Projection will satisfy both Q and U if enforced.</li>
        <li><strong>Real-time projection (debounced):</strong> fast, lower-iteration preview runs after you stop moving a slider for ~400 ms. Use **Full projection** for high-accuracy solves.</li>
      </ul>
    </section>

    <!-- 4. Presets -->
    <section id="g-presets">
      <h3>4. Presets</h3>
      <p>Each preset button loads a full parameter set. Hover a preset to see its values and intent.</p>
      <ul>
        <li><strong>Nominal:</strong> Baseline NOAK settings you used in sensitivity analyses.</li>
        <li><strong>ARIES-AT:</strong> Approx. advanced tokamak case; higher ηE, moderate Pf/S, relatively low overnight cost density.</li>
        <li><strong>ARC:</strong> Approx. compact high-field tokamak; Pf/S≈4, ηE≈0.35, higher overnight cost density.</li>
        <li><strong>SPARC-like:</strong> Illustrative research-class surrogate; lower XS, higher costs.</li>
        <li><strong>Optimistic:</strong> Aggressive, future-leaning assumptions: higher Pf/S, XS, ηE; faster replacement; favorable POE and capital cost.</li>
        <li><strong>Conservative (non-viable):</strong> Cautious stress-test: lower Pf/S & ηE, shorter life, higher costs & capital—typically \(Q_{\mathrm{econ}}<1\).</li>
      </ul>
    </section>

    <!-- 5. Visualization -->
    <section id="g-visualization">
      <h3>5. Visualization (Heatmap & Contours)</h3>
      <ul>
        <li>Choose **X** and **Y** parameters; set **min/max** ranges and **resolution**.</li>
        <li>Background colors show \(Q_{\mathrm{econ}}\); darker red &lt; 1, lighter → blue &gt; 1.</li>
        <li>Enter multiple **Contour Q levels** (e.g., <span class="mono">1.0, 1.5, 2.0</span>) to overlay isolines with a legend.</li>
        <li>Axes include labels (parameter name + units) and tick marks based on your ranges.</li>
        <li>Use **Download PNG** to save the plot image.</li>
      </ul>
    
<p><strong>Reset view:</strong> Use the <em>Reset view</em> button at the top‑right of the chart (or press the <span class="mono">R</span> key). It restores the axis ranges to the defaults for the current axis pair:
<em>Pf/S vs XS</em> → x: 0.5–10, y: 0.5–6; <em>Pf/S vs τrep</em> → x: 0.5–10, y: 0–0.5. It does <em>not</em> change any parameter values or targets.</p>
</section>

    <!-- 6. Save/Restore & Export -->
    <section id="g-save">
      <h3>6. Save / Restore & Export</h3>
      <ul>
        <li><strong>Export JSON:</strong> saves the complete state (parameters, scales, locks, weights, targets, utilization constraint, viz settings). Also shown in the JSON box for copy/paste.</li>
        <li><strong>Import JSON / Apply JSON:</strong> restore a saved state from file or by pasting into the JSON box.</li>
        <li><strong>Export projections CSV:</strong> writes target Q projections (one row per target), including whether current x already satisfies each target.</li>
        <li><strong>Download PNG:</strong> saves the current heatmap plot.</li>
      </ul>
    </section>

    <!-- 7. Tips -->
    <section id="g-tips">
      <h3>7. Tips, Notes & FAQ</h3>
      <ul>
        <li><strong>Viability:</strong> \(Q_{\mathrm{econ}} \ge 1\) is necessary; many commercial cases target \(Q \ge 1.5\)–2.0 for margin.</li>
        <li><strong>Locks & Weights:</strong> Lock fixes parameters during projection; weights shape the distance metric—emphasize the variables you can realistically change.</li>
        <li><strong>Performance:</strong> If previews feel slow, reduce target count or temporarily disable real-time projection.</li>
        <li><strong>Keyboard:</strong> Press <span class="mono">?</span> to open this guide; <span class="mono">Esc</span> to close.</li>
        <li><strong>Data privacy:</strong> Everything runs locally in your browser; files you export are saved on your machine.</li>
      </ul>
    </section>
  </div>
</aside>

<script>
// Complete working implementation
const EPS=1e-12;
const PARAMS = [
  {key:"PfS", lab:"Pf/S", nominal:2.5, scaleSel:"PfS_scale", rng:"PfS_rng", num:"PfS_num", min:0.5, max:10, lock:"PfS_lock", w:"PfS_w"},
  {key:"tau_rep", lab:"tau_rep", nominal:0.10, scaleSel:"tau_rep_scale", rng:"tau_rep_rng", num:"tau_rep_num", min:0, max:0.5, lock:"tau_rep_lock", w:"tau_rep_w"},
  {key:"tau_life", lab:"tau_life", nominal:30, scaleSel:"tau_life_scale", rng:"tau_life_rng", num:"tau_life_num", min:5, max:60, lock:"tau_life_lock", w:"tau_life_w"},
  {key:"POE", lab:"POE", nominal:100, scaleSel:"POE_scale", rng:"POE_rng", num:"POE_num", min:20, max:200, lock:"POE_lock", w:"POE_w"},
  {key:"XS", lab:"XS", nominal:3.125, scaleSel:"XS_scale", rng:"XS_rng", num:"XS_num", min:0.5, max:6, lock:"XS_lock", w:"XS_w"},
  {key:"etaE", lab:"etaE", nominal:0.40, scaleSel:"etaE_scale", rng:"etaE_rng", num:"etaE_num", min:0.1, max:0.7, lock:"etaE_lock", w:"etaE_w"},
  {key:"cY", lab:"cY", nominal:0.0000, scaleSel:"cY_scale", rng:"cY_rng", num:"cY_num", min:0, max:0.01, lock:"cY_lock", w:"cY_w"},
  {key:"MS_S", lab:"MS_S", nominal:0.10, scaleSel:"MS_S_scale", rng:"MS_S_rng", num:"MS_S_num", min:0, max:1, lock:"MS_S_lock", w:"MS_S_w"},
  {key:"MS_ON", lab:"MS_ON", nominal:10.0, scaleSel:"MS_ON_scale", rng:"MS_ON_rng", num:"MS_ON_num", min:3, max:20, lock:"MS_ON_lock", w:"MS_ON_w"},
  {key:"iRate", lab:"i", nominal:5.0, scaleSel:"iRate_scale", rng:"iRate_rng", num:"iRate_num", min:0, max:15, lock:"iRate_lock", w:"iRate_w"},
];
const scales = {PfS:3.5,tau_rep:0.1,tau_life:30,POE:100,XS:3.1,etaE:0.40,cY:1e-3,MS_S:0.1,MS_ON:10,iRate:5};
const keyIndex = Object.fromEntries(PARAMS.map((p,i)=>[p.key,i]));
const UNITS = {
  PfS:'MW/m²', tau_rep:'y', tau_life:'y', POE:'$/MWh',
  XS:'MW·y/m²', etaE:'—', cY:'$/MJ', MS_S:'M$/m²', MS_ON:'M$/m²', iRate:'%'
};

const PRESETS = {
  nominal: {PfS:4.0, tau_rep:0.1, tau_life:30, POE:100, XS:3.125, etaE:0.40, cY:0, MS_S:0.1, MS_ON:10, iRate:5},
  "aries-at": {PfS:3.8, tau_rep:0.1, tau_life:30, POE:100, XS:3.0, etaE:0.58, cY:0, MS_S:0.32, MS_ON:7.7, iRate:5},
  arc: {PfS:4.0, tau_rep:0.1, tau_life:30, POE:100, XS:3.0, etaE:0.35, cY:0, MS_S:0.1, MS_ON:11.9, iRate:5},
  sparc: {PfS:3.1, tau_rep:0.1, tau_life:30, POE:100, XS:2.5, etaE:0.35, cY:0, MS_S:0.15, MS_ON:15, iRate:5},
  optimistic: {PfS:5.0, tau_rep:0.05, tau_life:40, POE:150, XS:5.0, etaE:0.50, cY:0, MS_S:0.05, MS_ON:7, iRate:3},
  conservative: {PfS:2.5, tau_rep:0.2, tau_life:20, POE:80, XS:2.0, etaE:0.30, cY:0.001, MS_S:0.3, MS_ON:15, iRate:8}
};

function sliderToValue(p, sVal){
  const s=document.getElementById(p.scaleSel).value, min=p.min, max=p.max;
  if (s==='log'){
    const lo=Math.max(min, (min>0?min:1e-6)), hi=max;
    const t=(sVal-min)/(max-min);
    return lo*Math.pow(hi/lo, t);
  }
  return sVal;
}

function valueToSlider(p, v){
  const s=document.getElementById(p.scaleSel).value, min=p.min, max=p.max;
  if (s==='log'){
    const lo=Math.max(min, (min>0?min:1e-6)), hi=max;
    const t=Math.log(Math.max(v,lo)/lo)/Math.log(hi/lo);
    return min+t*(max-min);
  }
  return Math.min(Math.max(v,min),max);
}

function Uof(p){ 
  const PfS=Math.max(p[0],EPS), tauRep=Math.max(p[1],0), XS=Math.max(p[4],EPS); 
  return 1/(1+PfS*tauRep/XS); 
}

function Qecon(p){
  const PfS=Math.max(p[0],EPS), tauRep=Math.max(p[1],0), tauLife=Math.max(p[2],EPS), POE=Math.max(p[3],EPS), XS=Math.max(p[4],EPS);
  const etaE=Math.min(Math.max(p[5],EPS),1-EPS), cY=Math.max(p[6],0), MS_S=Math.max(p[7],0), MS_ON=Math.max(p[8],0), iRate=Math.max(p[9],0);
  const U=1/(1+PfS*tauRep/XS);
  const Cg=8.76e-3*POE*etaE*PfS*U, Ct=31.5*cY*PfS*U, Cs=MS_S*(PfS/XS)*U;
  const r=0.01*iRate; 
  let Cc;
  if (r<1e-12) Cc=MS_ON/Math.max(tauLife,EPS);
  else { const a=Math.pow(1+r,tauLife); Cc=MS_ON*(r*a)/(a-1); }
  const den=Ct+Cs+Cc; 
  return den<=0?Infinity:Cg/den;
}

function readParams(){ return PARAMS.map(p => parseFloat(document.getElementById(p.num).value)); }
function readLocks(){ return PARAMS.map(p => document.getElementById(p.lock).checked ? 1 : 0); }
function readWeights(){ return PARAMS.map(p => Math.max(0, parseFloat(document.getElementById(p.w).value) || 0)); }

function setParams(arr){
  PARAMS.forEach((p,i)=>{
    const v=arr[i];
    document.getElementById(p.num).value=v;
    document.getElementById(p.rng).value=valueToSlider(p,v);
  });
}

let liveTimer=null;
function syncAttach(){
  PARAMS.forEach(p=>{
    const rng=document.getElementById(p.rng), num=document.getElementById(p.num), scl=document.getElementById(p.scaleSel);
    rng.addEventListener('input', ()=>{ num.value=sliderToValue(p, parseFloat(rng.value)); liveUpdate(); });
    num.addEventListener('input', ()=>{ rng.value=valueToSlider(p, parseFloat(num.value)); liveUpdate(); });
    scl.addEventListener('change', ()=>{ rng.value=valueToSlider(p, parseFloat(num.value)); liveUpdate(); });
  });
}

function renderX(){
  const x=readParams(); 
  const Q=Qecon(x), U=Uof(x);
  const badge=(Q>=1)? '<span class="badge ok">Viable</span>' : '<span class="badge bad">Infeasible</span>';
  document.getElementById('statusX').innerHTML = `${badge}\nQecon(x)=${Q.toFixed(6)}\nU(x)=${U.toFixed(6)}`;
}

function renderY(clear=false, html=''){ 
  document.getElementById('statusY').innerHTML = clear?'':html; 
}

function liveUpdate(){
  renderX(); 
  scheduleDraw();
  if (!document.getElementById('liveProj').checked) return;
  if (liveTimer) clearTimeout(liveTimer);
  liveTimer = setTimeout(()=>previewProjection(), 400);
}

function parseTargets(){
  const raw = document.getElementById('targetsInput').value || '';
  const arr = raw.split(',').map(s=>parseFloat(s.trim())).filter(v=>Number.isFinite(v) && v>0);
  return Array.from(new Set(arr)).sort((a,b)=>a-b);
}

function parseContours(){
  const raw = document.getElementById('contoursInput').value || '';
  const arr = raw.split(',').map(s=>parseFloat(s.trim())).filter(v=>Number.isFinite(v) && v>0);
  return Array.from(new Set(arr)).sort((a,b)=>a-b);
}

function formatParamList(y){ 
  return PARAMS.map((p,i)=> `${p.lab} = ${y[i].toFixed(6)}`).join('\n'); 
}

function softplus(z){ if(z>20) return z; if(z<-20) return Math.exp(z); return Math.log1p(Math.exp(z)); }
function inv_softplus(y){ if(y<1e-12) return -20; return Math.log(Math.exp(y)-1); }
function sigmoid(z){ if(z>=0){ const e=Math.exp(-z); return 1/(1+e);} const e=Math.exp(z); return e/(1+e);}
function inv_sigmoid(p){ const y=Math.min(Math.max(p,1e-12),1-1e-12); return Math.log(y/(1-y)); }

function zFromY(y){
  return [
    Math.log(Math.max(y[0],EPS)),
    inv_softplus(Math.max(y[1],0)),
    Math.log(Math.max(y[2],EPS)),
    Math.log(Math.max(y[3],EPS)),
    Math.log(Math.max(y[4],EPS)),
    inv_sigmoid(Math.min(Math.max(y[5],1e-6),1-1e-6)),
    inv_softplus(Math.max(y[6],0)),
    inv_softplus(Math.max(y[7],0)),
    inv_softplus(Math.max(y[8],0)),
    inv_softplus(Math.max(y[9],0))
  ];
}

function yFromZ(z){
  return [
    Math.exp(z[0]),
    softplus(z[1]),
    Math.exp(z[2]),
    Math.exp(z[3]),
    Math.exp(z[4]),
    sigmoid(z[5]),
    softplus(z[6]),
    softplus(z[7]),
    softplus(z[8]),
    softplus(z[9])
  ];
}

function readUtilConstraint(){
  return {
    enforce: document.getElementById('utilEnforce').checked,
    uMin: Math.max(0, Math.min(1, parseFloat(document.getElementById('utilMin').value) || 0))
  };
}

function objectiveFactory(x, T, wUser, lockMask, utilOpt){
  const wEff = PARAMS.map((p,i)=> Math.max(0, wUser[i]));
  const scale = PARAMS.map(p => scales[p.key]);
  return function obj(z){
    let y = yFromZ(z);
    for (let i=0;i<10;i++){ if (lockMask[i]) y[i] = x[i]; }
    let dist2 = 0;
    for (let i=0;i<10;i++){
      const wi = wEff[i]; 
      if (wi<=0) continue;
      const s = scale[i];
      const d = (y[i] - x[i]) / s;
      dist2 += wi * d * d;
    }
    const Q = Qecon(y);
    const violQ = Math.max(0, T - Q);
    let pen = 1e6 * violQ * violQ;
    if (utilOpt.enforce){
      const U = Uof(y);
      const violU = Math.max(0, utilOpt.uMin - U);
      pen += 1e6 * violU * violU;
    }
    return dist2 + pen;
  }
}

function nelderMeadLocked(f, x0, lockMask, maxIter=3000, tol=1e-9, initStep=0.25){
  const n=x0.length, alpha=1, gamma=2, rho=0.5, sigma=0.5;
  const zLock = x0.slice();
  function projectLocks(z){ 
    for (let i=0;i<n;i++){ if (lockMask[i]) z[i] = zLock[i]; } 
    return z; 
  }
  const simplex=new Array(n+1); 
  simplex[0]=projectLocks(x0.slice());
  for(let i=1;i<=n;i++){ 
    const v=x0.slice(); 
    v[i-1]+= initStep*(Math.abs(v[i-1])+1); 
    simplex[i]=projectLocks(v); 
  }
  let fvals=simplex.map(v=>f(v));
  function order(){ 
    const idx=[...Array(n+1).keys()].sort((a,b)=>fvals[a]-fvals[b]);
    const s2=idx.map(i=>simplex[i]), f2=idx.map(i=>fvals[i]);
    for(let i=0;i<=n;i++){ simplex[i]=s2[i]; fvals[i]=f2[i]; } 
  }
  let iter=0;
  while(iter++<maxIter){
    order();
    let size=0; 
    for(let i=1;i<=n;i++){ 
      let acc=0; 
      for(let j=0;j<n;j++){ 
        const d=simplex[i][j]-simplex[0][j]; 
        acc+=d*d; 
      } 
      size=Math.max(size,Math.sqrt(acc)); 
    }
    if(size<tol) break;
    const xc=new Array(n).fill(0); 
    for(let i=0;i<n;i++) for(let j=0;j<n;j++) xc[j]+=simplex[i][j]; 
    for(let j=0;j<n;j++) xc[j]/=n;
    const xr=projectLocks(new Array(n).fill(0).map((_,j)=> xc[j]+alpha*(xc[j]-simplex[n][j])));
    const fr=f(xr);
    if(fr<fvals[0]){
      const xe=projectLocks(new Array(n).fill(0).map((_,j)=> xc[j]+gamma*(xr[j]-xc[j])));
      const fe=f(xe);
      if(fe<fr){ simplex[n]=xe; fvals[n]=fe; } else { simplex[n]=xr; fvals[n]=fr; }
    } else if(fr<fvals[n-1]){ simplex[n]=xr; fvals[n]=fr; }
    else {
      let xcand;
      if(fr<fvals[n]) xcand=projectLocks(new Array(n).fill(0).map((_,j)=> xc[j]+rho*(xr[j]-xc[j])));
      else xcand=projectLocks(new Array(n).fill(0).map((_,j)=> xc[j]+rho*(simplex[n][j]-xc[j])));
      const fc=f(xcand);
      if(fc<fvals[n]){ simplex[n]=xcand; fvals[n]=fc; }
      else { 
        for(let i=1;i<=n;i++){ 
          for(let j=0;j<n;j++) simplex[i][j]=projectLocks(new Array(n).fill(0).map((_,k)=> simplex[0][k]+sigma*(simplex[i][k]-simplex[0][k])))[j]; 
          fvals[i]=f(simplex[i]); 
        } 
      }
    }
  }
  order(); 
  return {z:simplex[0], f:fvals[0], iter};
}

function projectToTarget(x, T, wUser, lockMask, utilOpt, fast=false){
  const z0=zFromY(x);
  const obj = objectiveFactory(x, T, wUser, lockMask, utilOpt);
  const it1=fast?1200:3000, it2=fast?1600:4000;
  const s1=nelderMeadLocked(obj, z0, lockMask, it1, 1e-10, 0.25);
  const s2=nelderMeadLocked(obj, s1.z, lockMask, it2, 1e-10, 0.1);
  let y=yFromZ(s2.z);
  for (let i=0;i<10;i++){ if (lockMask[i]) y[i]=x[i]; }
  return y;
}

function previewProjection(){
  const x=readParams(); 
  const Qx=Qecon(x); 
  const Ux=Uof(x);
  const targets = parseTargets(); 
  const wUser = readWeights(); 
  const locks = readLocks();
  const utilOpt = readUtilConstraint();
  if (targets.length===0){ 
    renderY(false, 'Please enter at least one positive target Q (e.g., 1.0, 1.5).'); 
    return; 
  }
  let html = [`Preview (fast):`, `Qecon(x)=${Qx.toFixed(6)} (U=${Ux.toFixed(6)})`];
  for (const T of targets){
    if (Qx >= T && (!utilOpt.enforce || Ux >= utilOpt.uMin)){
      html.push('', `Already satisfies target Q ≥ ${T.toFixed(3)}. Nearest point is x.`);
      continue;
    }
    const y = projectToTarget(x, T, wUser, locks, utilOpt, true);
    const Qy = Qecon(y), Uy=Uof(y);
    html.push('', `Projected to Q=${T.toFixed(3)} (${Qy.toFixed(6)}, U=${Uy.toFixed(6)}):`, formatParamList(y));
  }
  renderY(false, html.join('<br/>'));
}

function fullProjection(){
  const x=readParams(); 
  const Qx=Qecon(x); 
  const Ux=Uof(x);
  const targets = parseTargets(); 
  const wUser = readWeights(); 
  const locks = readLocks();
  const utilOpt = readUtilConstraint();
  if (targets.length===0){ 
    renderY(false, 'Please enter at least one positive target Q (e.g., 1.0, 1.5).'); 
    return; 
  }
  let html = [`Full projection:`, `Qecon(x)=${Qx.toFixed(6)} (U=${Ux.toFixed(6)})`];
  for (const T of targets){
    if (Qx >= T && (!utilOpt.enforce || Ux >= utilOpt.uMin)){
      html.push('', `Already satisfies target Q ≥ ${T.toFixed(3)}. Nearest point is x.`);
      continue;
    }
    const y = projectToTarget(x, T, wUser, locks, utilOpt, false);
    const Qy = Qecon(y), Uy=Uof(y);
    html.push('', `Projected to Q=${T.toFixed(3)} (${Qy.toFixed(6)}, U=${Uy.toFixed(6)}):`, formatParamList(y));
  }
  renderY(false, html.join('<br/>'));
}

function csvEscape(val){
  if (val === null || val === undefined) return '';
  const s = String(val);
  return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
}

function toFixedOr(val, d=6){
  if (!Number.isFinite(val)) return '';
  return Number(val).toFixed(d);
}

function exportProjectionsCSV(){
  const x = readParams();
  const Qx = Qecon(x), Ux = Uof(x);
  const targets = parseTargets();
  if (!targets.length){ 
    alert('Please enter at least one target Q (e.g., 1.0, 1.5).'); 
    return; 
  }

  const wUser = readWeights();
  const locks  = readLocks();
  const util   = readUtilConstraint();

  const cols = [
    'TargetQ','SatisfiedAtX','Q_at_y','U_at_y',
    'PfS','tau_rep','tau_life','POE','XS','etaE','cY','MS_S','MS_ON','i'
  ];
  const rows = [cols.join(',')];

  for (const T of targets){
    let satisfied = (Qx >= T);
    if (util.enforce) satisfied = satisfied && (Ux >= util.uMin);

    let y, Qy, Uy;
    if (satisfied){
      y = x.slice();
      Qy = Qx; Uy = Ux;
    } else {
      y = projectToTarget(x, T, wUser, locks, util, false);
      Qy = Qecon(y); Uy = Uof(y);
    }

    const data = [
      T.toFixed(3),
      satisfied ? 'TRUE' : 'FALSE',
      toFixedOr(Qy, 6),
      toFixedOr(Uy, 6),
      toFixedOr(y[0], 6),
      toFixedOr(y[1], 6),
      toFixedOr(y[2], 6),
      toFixedOr(y[3], 6),
      toFixedOr(y[4], 6),
      toFixedOr(y[5], 6),
      toFixedOr(y[6], 6),
      toFixedOr(y[7], 6),
      toFixedOr(y[8], 6),
      toFixedOr(y[9], 6)
    ];
    rows.push(data.map(csvEscape).join(','));
  }

  const csv = rows.join('\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8'});
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; 
  a.download = 'qecon_projections.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

const canvas=document.getElementById('plot'); 
const ctx=canvas.getContext('2d',{willReadFrequently:true}); 
let rafId=null;
const MARGINS = {left:70, right:16, top:12, bottom:54};

function scheduleDraw(){ 
  if(rafId) cancelAnimationFrame(rafId); 
  rafId=requestAnimationFrame(drawPlot); 
}

function niceTicks(min, max, count=5){
  const span = max - min;
  if (span <= 0 || !isFinite(span)) return [min, max];
  const raw = span / Math.max(1, count);
  const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
  const mults = [1, 2, 2.5, 5, 10];
  let step = mults[0]*pow10, bestScore = Infinity;
  for (const m of mults){
    const st = m*pow10;
    const s = Math.abs(raw - st);
    if (s < bestScore){ bestScore = s; step = st; }
  }
  const start = Math.ceil(min/step)*step;
  const ticks = [];
  for (let v=start; v<=max+1e-12; v+=step) ticks.push(+v.toFixed(10));
  return ticks;
}

function setupSelectors(){
  const xp=document.getElementById('xParam'), yp=document.getElementById('yParam');
  PARAMS.forEach(p=>{ 
    const a=document.createElement('option'); 
    a.value=p.key; 
    a.text=`${p.lab}`;
    xp.appendChild(a);
    const b=document.createElement('option'); 
    b.value=p.key; 
    b.text=`${p.lab}`; 
    yp.appendChild(b); 
  });
  xp.value='PfS'; 
  yp.value='XS';
  ['xParam','yParam','xmin','xmax','ymin','ymax','resSelect','contoursInput'].forEach(id=>{
    document.getElementById(id).addEventListener('input', scheduleDraw);
  });
}

function colorForQ(Q){
  const clamp=(v,mn,mx)=>Math.max(mn,Math.min(mx,v));
  const t = clamp((Q-1)/1, -1, 1); 
  let r,g,b;
  if (t>=0){ 
    r=Math.floor(255*(1-t)); 
    g=Math.floor(220*t+30); 
    b=255; 
  }
  else { 
    const s=-t; 
    r=255; 
    g=Math.floor(180*(1-s)); 
    b=Math.floor(120*(1-s)); 
  }
  return [r,g,b,255];
}

function contourColors(levels){
  const base = ['#111827','#dc2626','#2563eb','#059669','#a855f7','#d97706','#0ea5e9','#16a34a'];
  return levels.map((_,i)=> base[i % base.length]);
}

function drawPlot(){
  const w=canvas.width, h=canvas.height;
  const xp=document.getElementById('xParam').value, yp=document.getElementById('yParam').value;
  ctx.clearRect(0,0,w,h);
  if (xp===yp) return;

  const xmin=parseFloat(document.getElementById('xmin').value);
  const xmax=parseFloat(document.getElementById('xmax').value);
  const ymin=parseFloat(document.getElementById('ymin').value);
  const ymax=parseFloat(document.getElementById('ymax').value);
  if (!(xmax>xmin && ymax>ymin)) return;

  const base=readParams(); 
  const xi=keyIndex[xp], yi=keyIndex[yp];
  const plotW = w - MARGINS.left - MARGINS.right;
  const plotH = h - MARGINS.top - MARGINS.bottom;

  // Heatmap
  const img = ctx.getImageData(0,0,w,h);
  const data = img.data;
  for(let j=0;j<plotH;j++){
    const v = ymin + (ymax-ymin)*(1 - j/plotH);
    for(let i=0;i<plotW;i++){
      const u = xmin + (xmax-xmin)*(i/plotW);
      const p=base.slice(); 
      p[xi]=u; 
      p[yi]=v;
      const Q=Qecon(p);
      const [r,g,b,a]=colorForQ(Q);
      const X = MARGINS.left + i;
      const Y = MARGINS.top + j;
      const idx = 4*(Y*w + X);
      data[idx]=r; 
      data[idx+1]=g; 
      data[idx+2]=b; 
      data[idx+3]=a;
    }
  }
  ctx.putImageData(img,0,0);

  // Contours
  const res=parseInt(document.getElementById('resSelect').value,10);
  const gx=res, gy=res;
  const Qg=Array.from({length:gy},()=>Array(gx).fill(0));
  for(let j=0;j<gy;j++){
    const v=ymin+(ymax-ymin)*j/(gy-1);
    for(let i=0;i<gx;i++){
      const u=xmin+(xmax-xmin)*i/(gx-1);
      const p=base.slice(); 
      p[xi]=u; 
      p[yi]=v;
      Qg[j][i]=Qecon(p);
    }
  }
  
  function toPx(u,v){
    const x = MARGINS.left + (u - xmin)/(xmax-xmin)*plotW;
    const y = MARGINS.top + (1 - (v - ymin)/(ymax-ymin))*plotH;
    return [x,y];
  }

  const levels = parseContours();
  const colors = contourColors(levels);

  levels.forEach((L,idx)=>{
    ctx.lineWidth=1.8; 
    ctx.strokeStyle=colors[idx]; 
    ctx.beginPath();
    for(let j=0;j<gy-1;j++){
      for(let i=0;i<gx-1;i++){
        const c=[Qg[j][i],Qg[j][i+1],Qg[j+1][i+1],Qg[j+1][i]];
        const u0=xmin+(xmax-xmin)*i/(gx-1);
        const v0=ymin+(ymax-ymin)*j/(gy-1);
        const du=(xmax-xmin)/(gx-1);
        const dv=(ymax-ymin)/(gy-1);
        const edges=[];
        if ((c[0]-L)*(c[3]-L)<=0){ 
          const t=(L-c[0])/(c[3]-c[0]+1e-12); 
          edges.push([u0, v0+t*dv]); 
        }
        if ((c[0]-L)*(c[1]-L)<=0){ 
          const t=(L-c[0])/(c[1]-c[0]+1e-12); 
          edges.push([u0+t*du, v0]); 
        }
        if ((c[1]-L)*(c[2]-L)<=0){ 
          const t=(L-c[1])/(c[2]-c[1]+1e-12); 
          edges.push([u0+du, v0+t*dv]); 
        }
        if ((c[3]-L)*(c[2]-L)<=0){ 
          const t=(L-c[3])/(c[2]-c[3]+1e-12); 
          edges.push([u0+t*du, v0+dv]); 
        }
        if (edges.length===2){
          const [x1,y1]=toPx(edges[0][0],edges[0][1]);
          const [x2,y2]=toPx(edges[1][0],edges[1][1]);
          ctx.moveTo(x1,y1); 
          ctx.lineTo(x2,y2);
        }
      }
    }
    ctx.stroke();
  });

  // Axes
  ctx.strokeStyle = '#111827'; 
  ctx.fillStyle = '#111827'; 
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(MARGINS.left, MARGINS.top);
  ctx.lineTo(MARGINS.left, MARGINS.top + plotH);
  ctx.moveTo(MARGINS.left, MARGINS.top + plotH);
  ctx.lineTo(MARGINS.left + plotW, MARGINS.top + plotH);
  ctx.stroke();

  ctx.font = '12px Inter, Arial, sans-serif';
  ctx.textAlign = 'center'; 
  ctx.textBaseline = 'top';

  // X ticks
  const xt = niceTicks(xmin, xmax, 5);
  xt.forEach(val=>{
    const x = MARGINS.left + (val - xmin)/(xmax - xmin)*plotW;
    ctx.beginPath();
    ctx.moveTo(x, MARGINS.top + plotH);
    ctx.lineTo(x, MARGINS.top + plotH + 6);
    ctx.stroke();
    ctx.fillText(val.toFixed(2), x, MARGINS.top + plotH + 8);
  });

  // Y ticks
  const yt = niceTicks(ymin, ymax, 5);
  ctx.textAlign = 'right'; 
  ctx.textBaseline = 'middle';
  yt.forEach(val=>{
    const y = MARGINS.top + (1 - (val - ymin)/(ymax - ymin))*plotH;
    ctx.beginPath();
    ctx.moveTo(MARGINS.left - 6, y);
    ctx.lineTo(MARGINS.left, y);
    ctx.stroke();
    ctx.fillText(val.toFixed(2), MARGINS.left - 8, y);
  });

  // Axis labels
  ctx.textAlign = 'center'; 
  ctx.textBaseline = 'top';
  const xLabel = `${PARAMS[xi].lab} [${UNITS[xp]}]`;
  ctx.fillText(xLabel, MARGINS.left + plotW/2, MARGINS.top + plotH + 30);
  
  ctx.save();
  ctx.translate(18, MARGINS.top + plotH/2);
  ctx.rotate(-Math.PI/2);
  const yLabel = `${PARAMS[yi].lab} [${UNITS[yp]}]`;
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  // Draw markers for current and projected points
  const Qx = Qecon(base), Ux = Uof(base);
  const util = readUtilConstraint();
  const targets = parseTargets();
  const thresh = targets.length ? Math.min(...targets) : 1.0;
  const feasible = (Qx >= thresh) && (!util.enforce || Ux >= util.uMin);
  const xv = base[xi], yv = base[yi];

  // Draw current point marker
  if (isFinite(xv) && isFinite(yv)) {
    const [px, py] = toPx(xv, yv);
    ctx.save();
    ctx.lineWidth = 2;
    if (feasible) {
      ctx.strokeStyle = '#111827';
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(px, py, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#ef4444';
      ctx.beginPath();
      ctx.arc(px, py, 5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(px - 4, py - 4);
      ctx.lineTo(px + 4, py + 4);
      ctx.moveTo(px + 4, py - 4);
      ctx.lineTo(px - 4, py + 4);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Draw projected points
  try {
    const wUser = readWeights();
    const locks = readLocks();
    const utilOpt = readUtilConstraint();
    const projColors = ['#2563eb','#16a34a','#f59e0b','#ef4444','#8b5cf6','#06b6d4','#d946ef','#84cc16'];
    
    targets.forEach((T, i) => {
      const y = projectToTarget(base, T, wUser, locks, utilOpt, true);
      const xv2 = y[xi], yv2 = y[yi];
      if (isFinite(xv2) && isFinite(yv2)) {
        const [px, py] = toPx(xv2, yv2);
        const col = projColors[i % projColors.length];
        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = col;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.rect(px - 5, py - 5, 10, 10);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
    });
  } catch(e) {}

  // Update legend
  const legend = document.getElementById('legend');
  if (legend) {
    let html = '';
    html += '<span class="legend-row"><span class="swatch circle" style="border-color:#111827;background:#ffffff"></span> Current</span>';
    html += '<span class="legend-row"><span class="swatch circle infeasible"></span> Infeasible</span>';
    
    const projColors = ['#2563eb','#16a34a','#f59e0b','#ef4444','#8b5cf6','#06b6d4','#d946ef','#84cc16'];
    targets.forEach((T, i) => {
      const col = projColors[i % projColors.length];
      html += `<span class="legend-row"><span class="swatch square" style="border-color:${col};background:#ffffff"></span> Q=${T.toFixed(2)}</span>`;
    });
    
    if (levels.length > 0) {
      html += '<span class="legend-row">Contours: ' + levels.map(v => `Q=${v.toFixed(1)}`).join(', ') + '</span>';
    }
    
    legend.innerHTML = html;
  }
}

function exportJSON(){
  const obj = {
    params: Object.fromEntries(PARAMS.map(p => [p.key, parseFloat(document.getElementById(p.num).value)])),
    scales: Object.fromEntries(PARAMS.map(p => [p.key, document.getElementById(p.scaleSel).value])),
    locks: Object.fromEntries(PARAMS.map(p => [p.key, document.getElementById(p.lock).checked])),
    weights: Object.fromEntries(PARAMS.map(p => [p.key, parseFloat(document.getElementById(p.w).value)])),
    targets: parseTargets(),
    util: {
      enforce: document.getElementById('utilEnforce').checked,
      uMin: parseFloat(document.getElementById('utilMin').value)
    },
    viz: {
      xParam: document.getElementById('xParam').value,
      yParam: document.getElementById('yParam').value,
      xmin: parseFloat(document.getElementById('xmin').value),
      xmax: parseFloat(document.getElementById('xmax').value),
      ymin: parseFloat(document.getElementById('ymin').value),
      ymax: parseFloat(document.getElementById('ymax').value),
      res: parseInt(document.getElementById('resSelect').value, 10),
      contours: parseContours()
    }
  };
  const text = JSON.stringify(obj, null, 2);
  document.getElementById('jsonBox').value = text;
  const blob = new Blob([text], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'qecon_params.json';
  a.click();
  URL.revokeObjectURL(url);
}

function applyJSONText(){
  try {
    const obj = JSON.parse(document.getElementById('jsonBox').value);
    if (obj.params) {
      PARAMS.forEach(p => {
        const v = Number(obj.params[p.key]);
        if (isFinite(v)) {
          document.getElementById(p.num).value = v;
          document.getElementById(p.rng).value = valueToSlider(p, v);
        }
      });
    }
    if (obj.scales) {
      PARAMS.forEach(p => {
        const s = obj.scales[p.key];
        if (s === 'lin' || s === 'log') {
          document.getElementById(p.scaleSel).value = s;
          document.getElementById(p.rng).value = valueToSlider(p, parseFloat(document.getElementById(p.num).value));
        }
      });
    }
    if (obj.locks) {
      PARAMS.forEach(p => {
        document.getElementById(p.lock).checked = !!obj.locks[p.key];
      });
    }
    if (obj.weights) {
      PARAMS.forEach(p => {
        const w = obj.weights[p.key];
        if (Number.isFinite(w)) document.getElementById(p.w).value = w;
      });
    }
    if (obj.targets && Array.isArray(obj.targets)) {
      document.getElementById('targetsInput').value = obj.targets.join(', ');
    }
    if (obj.util) {
      document.getElementById('utilEnforce').checked = !!obj.util.enforce;
      document.getElementById('utilMin').value = Number(obj.util.uMin || 0.8);
    }
    if (obj.viz) {
      document.getElementById('xParam').value = obj.viz.xParam || 'PfS';
      document.getElementById('yParam').value = obj.viz.yParam || 'XS';
      document.getElementById('xmin').value = obj.viz.xmin ?? 0.5;
      document.getElementById('xmax').value = obj.viz.xmax ?? 6;
      document.getElementById('ymin').value = obj.viz.ymin ?? 0.5;
      document.getElementById('ymax').value = obj.viz.ymax ?? 6;
      document.getElementById('resSelect').value = String(obj.viz.res ?? 96);
      if (obj.viz.contours && obj.viz.contours.length > 0) {
        document.getElementById('contoursInput').value = obj.viz.contours.join(', ');
      }
    }
    renderX();
    renderY(true);
    scheduleDraw();
  } catch(e) {
    alert('Invalid JSON.');
  }
}

function importJSONFile(f) {
  const r = new FileReader();
  r.onload = e => {
    document.getElementById('jsonBox').value = e.target.result;
    applyJSONText();
  };
  r.readAsText(f);
}

function downloadPNG() {
  const link = document.createElement('a');
  link.download = 'qecon_heatmap.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// Wire up all buttons and controls
document.getElementById('btnQ').addEventListener('click', renderX);
document.getElementById('btnProj').addEventListener('click', fullProjection);
document.getElementById('btnReset').addEventListener('click', () => {
  const p = PRESETS['nominal'];
  setParams([p.PfS, p.tau_rep, p.tau_life, p.POE, p.XS, p.etaE, p.cY, p.MS_S, p.MS_ON, p.iRate]);
  PARAMS.forEach(p => {
    document.getElementById(p.lock).checked = false;
    document.getElementById(p.w).value = 1;
  });
  document.getElementById('targetsInput').value = '1.0, 1.5';
  document.getElementById('contoursInput').value = '1.0, 1.5, 2.0';
  document.getElementById('utilEnforce').checked = true;
  document.getElementById('utilMin').value = '0.80';
  renderX();
  renderY(true);
  scheduleDraw();
});
document.getElementById('btnExport').addEventListener('click', exportJSON);
document.getElementById('btnApplyJSON').addEventListener('click', applyJSONText);
document.getElementById('btnDownloadPNG').addEventListener('click', downloadPNG);
document.getElementById('btnImport').addEventListener('click', () => document.getElementById('fileImport').click());
document.getElementById('fileImport').addEventListener('change', e => {
  if (e.target.files.length > 0) importJSONFile(e.target.files[0]);
});
document.getElementById('btnExportCSV').addEventListener('click', exportProjectionsCSV);
document.getElementById('liveProj').addEventListener('change', () => {
  if (document.getElementById('liveProj').checked) previewProjection();
  else renderY(true);
});

// Preset buttons
document.querySelectorAll('.preset-bar button').forEach(btn => {
  const preset = PRESETS[btn.dataset.preset];
  if (preset) {
    btn.addEventListener('click', () => {
      const p = PRESETS[btn.dataset.preset];
      if (!p) return;
      setParams([p.PfS, p.tau_rep, p.tau_life, p.POE, p.XS, p.etaE, p.cY, p.MS_S, p.MS_ON, p.iRate]);
      renderX();
      scheduleDraw();
    });
  }
});

// Axis quick-set buttons
document.getElementById('btnAxesPfS_XS').addEventListener('click', () => {
  document.getElementById('xParam').value = 'PfS';
  document.getElementById('yParam').value = 'XS';
  document.getElementById('xmin').value = 0.5;
  document.getElementById('xmax').value = 10;
  document.getElementById('ymin').value = 0.5;
  document.getElementById('ymax').value = 6;
  scheduleDraw();
});

document.getElementById('btnAxesPfS_tau').addEventListener('click', () => {
  document.getElementById('xParam').value = 'PfS';
  document.getElementById('yParam').value = 'tau_rep';
  document.getElementById('xmin').value = 0.5;
  document.getElementById('xmax').value = 10;
  document.getElementById('ymin').value = 0;
  document.getElementById('ymax').value = 0.5;
  scheduleDraw();
});

// Initialize everything
setupSelectors();
syncAttach();
setParams(PARAMS.map(p => p.nominal));
renderX();
renderY(true);
scheduleDraw();
</script>

<script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    var guideBtn=document.getElementById('btnGuide');
    var guideModal=document.getElementById('guideModal');
    var guideBackdrop=document.getElementById('guideBackdrop');
    var guideClose=document.getElementById('guideClose');
    function openGuide(){ if(!guideBackdrop||!guideModal) return; guideBackdrop.classList.remove('hidden'); guideModal.classList.remove('hidden'); guideModal.setAttribute('aria-hidden','false'); }
    function closeGuide(){ if(!guideBackdrop||!guideModal) return; guideBackdrop.classList.add('hidden'); guideModal.classList.add('hidden'); guideModal.setAttribute('aria-hidden','true'); }
    if (guideBtn) guideBtn.addEventListener('click', openGuide);
    if (guideClose) guideClose.addEventListener('click', closeGuide);
    if (guideBackdrop) guideBackdrop.addEventListener('click', closeGuide);
    document.addEventListener('keydown', function(e){ if (e.key==='Escape') closeGuide(); if (e.key==='?' || (e.shiftKey && e.key==='/')) openGuide(); });
  }catch(e){ console.warn('Guide wiring failed', e); }
});
</script>


<script>
(function(){
  function maybePreview(){
    if (document.getElementById('liveProj') && document.getElementById('liveProj').checked){
      try{ previewProjection(); }catch(e){}
    }
  }
  function hook(id, evts=['input','change']){
    var el = document.getElementById(id);
    if (!el) return;
    evts.forEach(function(evt){
      el.addEventListener(evt, function(){
        try{ if (typeof scheduleDraw==='function') scheduleDraw(); }catch(e){}
        maybePreview();
      });
    });
  }
  hook('targetsInput', ['input','change']);
  hook('contoursInput', ['input','change']);
  hook('utilEnforce', ['change']);
  hook('utilMin', ['input','change']);
  try{
    (PARAMS || []).forEach(function(p){
      var w = document.getElementById(p.w);
      var L = document.getElementById(p.lock);
      if (w){
        ['input','change'].forEach(function(evt){
          w.addEventListener(evt, function(){
            try{ if (typeof scheduleDraw==='function') scheduleDraw(); }catch(e){}
            maybePreview();
          });
        });
      }
      if (L){
        L.addEventListener('change', function(){
          try{ if (typeof scheduleDraw==='function') scheduleDraw(); }catch(e){}
          maybePreview();
        });
      }
    });
  }catch(e){}
})();
</script>


<script>
(function(){
  function resetViewToDefault(){
    var xSel = document.getElementById('xParam').value;
    var ySel = document.getElementById('yParam').value;
    // If using the two supported axis presets, use their canonical ranges (same as the axis buttons)
    if (xSel === 'PfS' && ySel === 'XS'){
      document.getElementById('xmin').value = 0.5;
      document.getElementById('xmax').value = 10;
      document.getElementById('ymin').value = 0.5;
      document.getElementById('ymax').value = 6;
    } else if (xSel === 'PfS' && ySel === 'tau_rep'){
      document.getElementById('xmin').value = 0.5;
      document.getElementById('xmax').value = 10;
      document.getElementById('ymin').value = 0;
      document.getElementById('ymax').value = 0.5;
    } else {
      // Generic fallback: use PARAMS metadata if available, otherwise keep current
      try {
        var PX = (PARAMS||[]).find(p => p.key === xSel);
        var PY = (PARAMS||[]).find(p => p.key === ySel);
        if (PX && typeof PX.min==='number' && typeof PX.max==='number'){
          document.getElementById('xmin').value = PX.min;
          document.getElementById('xmax').value = PX.max;
        }
        if (PY && typeof PY.min==='number' && typeof PY.max==='number'){
          document.getElementById('ymin').value = PY.min;
          document.getElementById('ymax').value = PY.max;
        }
      }catch(e){ /* ignore */ }
    }
    try { if (typeof scheduleDraw==='function') scheduleDraw(); } catch(e){}
  }
  var btn = document.getElementById('btnResetView');
  if (btn){
    btn.addEventListener('click', resetViewToDefault);
  }
})();
</script>


<script>
(function(){
  function doReset(){
    try{ document.getElementById('btnResetView').click(); }catch(e){
      try{ resetViewToDefault(); }catch(_) {}
    }
  }
  document.addEventListener('keydown', function(e){
    // Press 'R' to reset view (ignored while the guide modal is open)
    var guideOpen = false;
    try{
      var gb = document.getElementById('guideBackdrop');
      var gm = document.getElementById('guideModal');
      guideOpen = (gb && !gb.classList.contains('hidden')) || (gm && !gm.classList.contains('hidden'));
    }catch(e){}
    if (!guideOpen && !e.ctrlKey && !e.metaKey && !e.altKey && (e.key==='r' || e.key==='R')){
      e.preventDefault();
      doReset();
    }
  });
})();
</script>


<script id="plotly-overlay-script">
(function(){
  // Safety: run after the app has defined scheduleDraw, etc.
  function ensureReady(){
    return (typeof window.scheduleDraw === 'function' &&
            typeof window.readParams === 'function' &&
            typeof window.Qecon === 'function' &&
            typeof window.projectToTarget === 'function');
  }
  function parseLevels(){
    var raw = (document.getElementById('contoursInput')||{}).value || '';
    var arr = raw.split(',').map(function(s){ return parseFloat(s.trim()); }).filter(function(v){ return isFinite(v) && v>0; });
    if (!arr.some(function(v){ return Math.abs(v-1.0) < 1e-9; })) arr.push(1.0);
    var uniq = Array.from(new Set(arr)).sort(function(a,b){ return a-b; });
    return uniq;
  }
  function renderPlotlyFromState(autoFit){
    var div = document.getElementById('plotlyOverlay');
    if (!div || !window.Plotly) return;

    var xp = document.getElementById('xParam').value;
    var yp = document.getElementById('yParam').value;
    if (xp === yp) { Plotly.purge(div); return; }

    // Typed bounds
    var xmin = parseFloat(document.getElementById('xmin').value);
    var xmax = parseFloat(document.getElementById('xmax').value);
    var ymin = parseFloat(document.getElementById('ymin').value);
    var ymax = parseFloat(document.getElementById('ymax').value);
    if (!(xmax>xmin && ymax>ymin)) { Plotly.purge(div); return; }

    var base = readParams();
    var keyIndex = Object.fromEntries(PARAMS.map(function(p,i){ return [p.key, i]; }));
    var xi = keyIndex[xp], yi = keyIndex[yp];
    var N = parseInt((document.getElementById('resSelect')||{}).value || '96', 10) || 96;

    // Targets/levels
    var levels = parseLevels();

    // Current and projected points
    var lockMask = readLocks();
    var wUser = readWeights();
    var utilOpt = readUtilConstraint();
    var curX = base[xi], curY = base[yi];
    var xMinPts = curX, xMaxPts = curX, yMinPts = curY, yMaxPts = curY;
    var projTraces = [];
    levels.forEach(function(T){
      try {
        var y = projectToTarget(base, T, wUser, lockMask, utilOpt, true);
        var px = y[xi], py = y[yi];
        if (isFinite(px) && isFinite(py)){
          xMinPts = Math.min(xMinPts, px); xMaxPts = Math.max(xMaxPts, px);
          yMinPts = Math.min(yMinPts, py); yMaxPts = Math.max(yMaxPts, py);
          projTraces.push({type:'scatter', mode:'markers', name:'Projection Q='+T, x:[px], y:[py], marker:{symbol:'x', size:10},
            hovertemplate:'Q='+T+'<br>"+xp+": %{x:.4g}<br>"+yp+": %{y:.4g}<extra></extra>'});
        }
      } catch(e){}
    });

    // Decide final ranges
    var fxmin = xmin, fxmax = xmax, fymin = ymin, fymax = ymax;
    if (autoFit){
      var pxmin = Math.min(xMinPts, xmin), pxmax = Math.max(xMaxPts, xmax);
      var pymin = Math.min(yMinPts, ymin), pymax = Math.max(yMaxPts, ymax);
      var dx = Math.max(1e-12, pxmax - pxmin), dy = Math.max(1e-12, pymax - pymin);
      var pad = 0.08;
      fxmin = Math.min(xmin, pxmin - pad*dx);
      fxmax = Math.max(xmax, pxmax + pad*dx);
      fymin = Math.min(ymin, pymin - pad*dy);
      fymax = Math.max(ymax, pymax + pad*dy);
    }

    // Build grid over final ranges to avoid white space
    var xs = Array.from({length:N}, function(_,i){ return fxmin + (fxmax - fxmin)*i/(N-1); });
    var ys = Array.from({length:N}, function(_,j){ return fymin + (fymax - fymin)*j/(N-1); });
    var z = new Array(ys.length);
    for (var j=0;j<ys.length;j++){
      var row = new Array(xs.length);
      for (var i=0;i<xs.length;i++){
        var p = base.slice(); p[xi]=xs[i]; p[yi]=ys[j];
        row[i] = Qecon(p);
      }
      z[j] = row;
    }

    var heat = {type:'heatmap', x:xs, y:ys, z:z, showscale:true, colorbar:{title:'Qecon'},
      hovertemplate: xp+': %{x:.4g}<br>'+yp+': %{y:.4g}<br>Qecon: %{z:.4g}<extra></extra>', name:'Qecon heatmap'};
    var contourTraces = levels.map(function(L){
      return {type:'contour', x:xs, y:ys, z:z, autocontour:false, contours:{start:L, end:L, size:1e-9, coloring:'lines', showlabels:false}, line:{color:'#111', width:2}, showscale:false, name:'Q = '+L, hoverinfo:'skip'};
    });
    var currentTrace = {type:'scatter', mode:'markers', name:'Current point', x:[curX], y:[curY], marker:{size:10},
      hovertemplate:'Current<br>'+xp+': %{x:.4g}<br>'+yp+': %{y:.4g}<extra></extra>'};

    var UNITS = {PfS:'MW/m²', tau_rep:'y', tau_life:'y', POE:'$/MWh', XS:'MW·y/m²', etaE:'—', cY:'$/MJ', MS_S:'M$/m²', MS_ON:'M$/m²', iRate:'%'};
    var xLabel = (PARAMS[xi].lab || xp) + (UNITS[xp] ? ' ['+UNITS[xp]+']' : '');
    var yLabel = (PARAMS[yi].lab || yp) + (UNITS[yp] ? ' ['+UNITS[yp]+']' : '');

    var layout = {
      title: {text:'Fusion Parameter Isoquants', x:0.5, xanchor:'center'},
      xaxis: {title:xLabel, range:[fxmin, fxmax]},
      yaxis: {title:yLabel, range:[fymin, fymax]},
      margin: {l:70, r:20, t:70, b:90},
      legend: {orientation:'h', x:0, y:-0.2, xanchor:'left', yanchor:'top', bgcolor:'rgba(255,255,255,0.8)', bordercolor:'#ccc', borderwidth:1}
    };

    var traces = [heat].concat(contourTraces, [currentTrace]).concat(projTraces);
    Plotly.react(div, traces, layout, {responsive:true, displaylogo:false});
  }

  function install(){
    // Monkey-patch scheduleDraw to also render Plotly (no changes to existing logic)
    if (window._origScheduleDraw) return; // avoid double patch
    window._origScheduleDraw = window.scheduleDraw;
    window.scheduleDraw = function(){ try{ window._origScheduleDraw(); }catch(e){} renderPlotlyFromState(false); };

    // Reset View re-fits to include all points
    var rv = document.getElementById('btnResetView');
    if (rv){
      rv.addEventListener('click', function(){ renderPlotlyFromState(true); }, true);
    }

    
    // Redraw on manual bound edits (strictly use typed bounds)
    ['xmin','xmax','ymin','ymax'].forEach(function(id){
      var el = document.getElementById(id);
      if (el){
        el.addEventListener('input', function(){ renderPlotlyFromState(false); }, true);
      }
    });
// Initial render
    renderPlotlyFromState(true);

    // Keep plot updated if container resizes
    window.addEventListener('resize', function(){ if (document.getElementById('plotlyOverlay')) Plotly.Plots.resize('plotlyOverlay'); });
  }

  if (document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', function(){ if (ensureReady()) install(); else setTimeout(install, 0); });
  } else {
    if (ensureReady()) install(); else setTimeout(install, 0);
  }
})();
</script>


<script id="tooltip-init">
(function(){
  function formatPresetTooltip(p){
    if(!p) return '';
    return [
      'Pf/S='+p.PfS,
      '\u03C4rep='+p.tau_rep,
      '\u03C4life='+p.tau_life,
      'POE='+p.POE,
      'XS='+p.XS,
      '\u03B7E='+p.etaE,
      'cY='+p.cY,
      'MS_S='+p.MS_S,
      'MS_ON='+p.MS_ON,
      'i='+p.iRate
    ].join(', ');
  }
  function getPresets(){
    try{
      if (typeof PRESETS !== 'undefined') return PRESETS;
      if (typeof window !== 'undefined' && window.PRESETS) return window.PRESETS;
    }catch(e){}
    return null;
  }
  function applyTooltips(){
    var P = getPresets();

    document.querySelectorAll('.preset-bar button').forEach(function(btn){
      var key = btn.dataset.preset;
      var p = P && P[key];
      var label = btn.textContent.trim();
      var text = p ? ('Preset "'+label+'": '+formatPresetTooltip(p)) : ('Preset "'+label+'"');
      btn.setAttribute('data-tooltip', text);
    });

    var r = document.getElementById('btnReset');
    if (r){
      var txt = 'Reset to Nominal';
      if (P && P['nominal']) txt += ': '+formatPresetTooltip(P['nominal']);
      r.setAttribute('data-tooltip', txt);
    }

    var map = {
      btnDownloadPNG: 'Download the current plot as a PNG image',
      btnAxesPfS_XS: 'Quick axes: X = Pf/S, Y = XS; updates bounds',
      btnAxesPfS_tau: 'Quick axes: X = \u03C4rep; updates bounds',
      btnResetView: 'Reset view: fit axes to include all points and contours'
    };
    Object.keys(map).forEach(function(id){
      var el = document.getElementById(id);
      if (el) el.setAttribute('data-tooltip', map[id]);
    });
  }
  function init(){
    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){
        applyTooltips(); setTimeout(applyTooltips, 0);
      });
    } else {
      applyTooltips(); setTimeout(applyTooltips, 0);
    }
  }
  init();
})();
</script>
</body>
</html>